#lang ivy1.7

include order

type value
type node
type nset # sets of nodes
instance ballot : unbounded_sequence

relation well_behaved(N:node)
relation intertwined(N:node)
relation intact(N:node)

relation member(N:node, S:nset)
relation is_quorum(Q:nset)
relation blocks_slices(S:nset, N:node)

trusted isolate node_properties = {
    # intact nodes are intertwined
    property intact(N) -> intertwined(N)
    # intertwined nodes are well-behaved
    property intertwined(N) -> well_behaved(N)
}

trusted isolate quorum_properties = {
    property [qi_intertwined] (exists N1 . intertwined(N1) & is_quorum(Q1) & member(N1,Q1)) & (exists N2 . intertwined(N2) & is_quorum(Q2) & member(N2,Q2)) -> exists N3 . well_behaved(N3) & member(N3,Q1) & member(N3,Q2)
    property [qi_intact] (exists N1 . intact(N1) & is_quorum(Q1) & member(N1,Q1)) & (exists N2 . intact(N2) & is_quorum(Q2) & member(N2,Q2)) -> exists N3 . intact(N3) & member(N3,Q1) & member(N3,Q2)
    # a set that blocks an intact nodes contains an intact node:
    property [blocking] (exists N . intact(N) & blocks_slices(S,N)) -> exists N2 . member(N2,S) & intact(N2)
    # the set of all intact nodes is a quorum
    property [intact_is_quorum] exists Q . (forall N . member(N,Q) <-> intact(N)) & is_quorum(Q)
}

axiom [cascade_thm] {
    individual q0:nset
    relation p(N:node)
    # assumptions:
    property is_quorum(q0) & (exists N0 . intact(N0) & member(N0,q0))
    property forall N . intact(N) & member(N,q0) -> p(N)
    # the conclusion:
    property (forall N . intact(N) -> p(N)) | (exists N2,S . intact(N2) & ~p(N2) & blocks_slices(S,N2) & (forall N3 . member(N3,S) -> (intact(N3) & p(N3))))
}

object protocol = {

    relation voted_prepared(N:node, B:ballot, V:value)
    relation accepted_prepared(N:node, B:ballot, V:value)
    relation confirmed_prepared(N:node, B:ballot, V:value)
    relation voted_committed(N:node, B:ballot, V:value)
    relation accepted_committed(N:node, B:ballot, V:value)
    relation confirmed_committed(N:node, B:ballot, V:value)
    relation nomination_output(N:node, V:value)
    relation started(N:node, B:ballot)
    relation left_ballot(N:node, B:ballot)

    # messages received
    relation received_vote_prepare(N1:node, N2:node, B:ballot, V:value)
    relation received_accept_prepare(N1:node, N2:node, B:ballot, V:value)
    relation received_vote_commit(N1:node, N2:node, B:ballot, V:value)
    relation received_accept_commit(N1:node, N2:node, B:ballot, V:value)

    object actions = { # workaround to avoid `with protocol`, which imports sub-isolates of protocol...

        after init {
            voted_prepared(N,B,V) := false;
            accepted_prepared(N,B,V) := false;
            confirmed_prepared(N,B,V) := false;
            voted_committed(N,B,V) := false;
            accepted_committed(N,B,V) := false;
            confirmed_committed(N,B,V) := false;
            nomination_output(N,X) := false;
            left_ballot(N,B) := false;
            started(N,B) := false;
            received_vote_prepare(N1,N2,B,V) := false;
            received_vote_commit(N1,N2,B,V) := false;
            received_accept_prepare(N1,N2,B,V) := false;
            received_accept_commit(N1,N2,B,V) := false;

            # TODO: shortcut for now:
            l2s_d(N:node) := true;
            l2s_d(B:ballot) := true;
            l2s_d(V:value) := true;
        }

        action nomination_update(n:node, v:value) = {
            nomination_output(n,V) := V = v;
        }

        action change_ballot(n:node, b:ballot) = {
            require ~left_ballot(n, b) & ~started(n, b);
            left_ballot(n,B) := B < b;
            started(n,b) := true;
            # now vote prepared:
            local bmax:ballot, vmax:value {
                # use the highest confirmed prepared value or, if none exists, the nomination output:
                require
                    ((forall B,V . B < b -> ~confirmed_prepared(n,B,V)) & nomination_output(n,vmax))
                    | (bmax < b & confirmed_prepared(n,bmax,vmax) & (forall B,V . B < b & confirmed_prepared(n,B,V) -> (B <= bmax)));
                voted_prepared(n, b, vmax) := true; # note we vote to prepare only once per ballot. this may be crucial for liveness as we don't want intact nodes voting to commit different values in the same ballot.
            };

        }

        # n1 receives a new vote to prepare (b,v); it checks whether quorum threshold is reached and, if so, accepts (b,v) as prepared unless it accepted a different, earlier value as committed.
        action receive_vote_prepare(na:node, nb:node, b:ballot, v:value) = {
            require voted_prepared(nb,b,v);
            received_vote_prepare(na,nb,b,v) := true;
            if (exists Q . is_quorum(Q) & member(na,Q) &
                   (forall N . member(N,Q) -> (received_vote_prepare(na,N,b,v) | received_accept_prepare(na,N,b,v)))) &
               (forall B,V . ~(accepted_committed(na,B,V) & B < b & V ~= v)) & # not accepted anything contradictory
               (forall V . ~accepted_prepared(na,b,V)) # do not accept twice
            {
                accepted_prepared(na,b,v) := true;
            };
        }


        action receive_accept_prepare(na:node, nb:node, b:ballot, v:value) = {
            require accepted_prepared(nb,b,v);
            received_accept_prepare(na,nb,b,v) := true;
            if exists Q . is_quorum(Q) & member(na,Q) & forall N . member(N,Q) -> received_accept_prepare(na,N,b,v) {
                confirmed_prepared(na,b,v) := true; # we must confirm prepared even if we left the ballot because that's used to pick the value to prepare in higher ballots; not doing it would be a liveness issue because, even in a long-enough ballot, nodes would not converge on the same confirmed prepared value.
                # TODO: in fact, nodes in SCP remember the highest bla bla... and we need to confirm based on this information (see comment at the top of this file)
                if ~left_ballot(na,b) {
                    voted_committed(na,b,v) := true;
                    # NOTE: we do not vote if we left ballot b already. This is important because if anything has already been voted prepared at a higher ballot, then we risk a contradiction; this would violate the invariant stating that votes to commit are not contradicted unless they have been overruled.
                    # NOTE: we could add note to vote twice, but that does not seem to cause harm
                };
            };
            if ((exists Q . is_quorum(Q) & member(na,Q) & (forall N . member(N,Q) -> (received_vote_prepare(na,N,b,v) | received_accept_prepare(na,N,b,v)))) | (exists S . blocks_slices(S,na) & (forall N . member(N,S) -> received_accept_prepare(na,N,b,v)))) &
                   (forall B,V . ~(accepted_committed(na,B,V) & B < b & V ~= v)) & # not accepted anything contradictory
                   (forall V . ~accepted_prepared(na,b,V)) # do not accept twice
            {
                accepted_prepared(na,b,v) := true;
            };
        }

        action receive_vote_commit(na:node, nb:node, b:ballot, v:value) = {
            require voted_committed(nb,b,v);
            received_vote_commit(na,nb,b,v) := true;
            if (exists Q . is_quorum(Q) & member(na,Q) &
                   (forall N . member(N,Q) -> (received_vote_commit(na,N,b,v) | received_accept_commit(na,N,b,v)))) &
               (forall B,V . ~(accepted_prepared(na,B,V) & b < B & V ~= v)) & # not accepted anything contradictory
               (forall V . ~accepted_committed(na,b,V)) & # do not accept commit twice
               (confirmed_prepared(na,b,v)) # accept committed only if confirmed prepared. NOTE: otherwise befouled nodes have no link with the previous ballots since Byzantine node can make them accept anything.
            {
                accepted_committed(na,b,v) := true;
            };
        }

        action receive_accept_commit(na:node, nb:node, b:ballot, v:value) = {
            require accepted_committed(nb,b,v);
            received_accept_commit(na,nb,b,v) := true;
            if exists Q . is_quorum(Q) & member(na,Q) & forall N . member(N,Q) -> received_accept_commit(na,N,b,v) {
                confirmed_committed(na,b,v) := true;
            };
            if ((exists Q . is_quorum(Q) & member(na,Q) &
                    (forall N . member(N,Q) -> (received_vote_commit(na,N,b,v) | received_accept_commit(na,N,b,v)))) |
                (exists S . blocks_slices(S,na) & (forall N . member(N,S) -> received_accept_commit(na,N,b,v)))) &
                (forall B,V . ~(accepted_prepared(na,B,V) & b < B & V ~= v)) & # not accepted anything contradictory
                (forall V . ~accepted_committed(na,b,V)) & # do not accept twice.
                (confirmed_prepared(na,b,v)) # accept committed only if confirmed prepared. NOTE: otherwise befouled nodes have no link with the previous ballots since Byzantine node can make them accept anything.
            {
                accepted_committed(na,b,v) := true;
            };
        }

        action byzantine_step = {
            voted_prepared(N,B,X) := *;
            require ~(well_behaved(N) & (voted_prepared(N,B,X) ~= old voted_prepared(N,B,X)));
            accepted_prepared(N,B,X) := *;
            require ~(well_behaved(N) & (accepted_prepared(N,B,X) ~= old accepted_prepared(N,B,X)));
            voted_committed(N,B,X) := *;
            require ~(well_behaved(N) & (voted_committed(N,B,X) ~= old voted_committed(N,B,X)));
            accepted_committed(N,B,X) := *;
            require ~(well_behaved(N) & (accepted_committed(N,B,X) ~= old accepted_committed(N,B,X)));
            confirmed_prepared(N,B,V) := *;
            require ~(well_behaved(N) & (confirmed_prepared(N,B,X) ~= old confirmed_prepared(N,B,X)));
            confirmed_committed(N,B,V) := *;
            require ~(well_behaved(N) & (confirmed_committed(N,B,X) ~= old confirmed_committed(N,B,X)));
            nomination_output(N,V) := *;
            require ~(well_behaved(N) & (nomination_output(N,X) ~= old nomination_output(N,X)));
            started(N,B) := *;
            require ~(well_behaved(N) & (started(N,B) ~= old started(N,B)));
            left_ballot(N,B) := *;
            require ~(well_behaved(N) & (left_ballot(N,B) ~= old left_ballot(N,B)));
            received_vote_prepare(N1,N2,B,V) := *;
            require ~(well_behaved(N1) & (received_vote_prepare(N1,N2,B,V) ~= old received_vote_prepare(N1,N2,B,V)));
            received_accept_prepare(N1,N2,B,V) := *;
            require ~(well_behaved(N1) & (received_accept_prepare(N1,N2,B,V) ~= old received_accept_prepare(N1,N2,B,V)));
            received_vote_commit(N1,N2,B,V) := *;
            require ~(well_behaved(N1) & (received_vote_commit(N1,N2,B,V) ~= old received_vote_commit(N1,N2,B,V)));
            received_accept_commit(N1,N2,B,V) := *;
            require ~(well_behaved(N1) & (received_accept_commit(N1,N2,B,V) ~= old received_accept_commit(N1,N2,B,V)));
        }

        export receive_vote_prepare
        export byzantine_step
        export receive_vote_commit
        export receive_accept_prepare
        export receive_accept_commit
        export change_ballot
        export nomination_update

    }

    isolate liveness_1 = {

        # temporal witnesses:
        individual b:ballot
        individual v:value
        individual n1:node
        individual n2:node
        individual n3:node
        individual s:nset

        isolate additional_safety = {
            property [cascade] intact(n1) & (exists Q . is_quorum(Q) & member(n1,Q) & (forall N . intact(N) & member(N,Q) -> accepted_prepared(N,b,v))) -> (forall N . intact(N) -> accepted_prepared(N,b,v)) | (exists N2,S . intact(N2) & ~accepted_prepared(N2,b,v) & blocks_slices(S,N2) & (forall N3 . member(N3,S) -> (intact(N3) & accepted_prepared(N3,b,v))))
            proof {
                tactic skolemize
                assume cascade_thm with p(X) = accepted_prepared(X,b,v), q0 = _Q
            }

            # TODO: this is provable: if a intact node accepted prepared (b,v), then n3 has not accepted anything contradictory.
            #invariant [inv1] intact(n3) & blocks_slices(s,n3) & (forall N .member(N,s) -> received_accept_prepare(n3,N,b,v)) -> accepted_prepared(n3,b,v)

        } with actions, node_properties

        temporal property (
            # negation of the ultimate goal:
            (exists N1,N2,B,V . intact(N1) & intact(N2) & ~globally (confirmed_prepared(N1,B,V) -> eventually confirmed_prepared(N2,B,V)))
            # witnesses n1, n2, b, and v
            & ( (forall N1,N2,B,V.
                    intact(N1) & intact(N2) -> globally (confirmed_prepared(N1,B,V) -> eventually confirmed_prepared(N2,B,V)))
                | ( intact(n1) & intact(n2) & ~globally (confirmed_prepared(n1,b,v) -> eventually confirmed_prepared(n2,b,v)))
              )
            ) -> eventually globally ((forall N . intact(N) -> accepted_prepared(N,b,v)) | (exists N2,S . intact(N2) & ~accepted_prepared(N2,b,v) & blocks_slices(S,N2) & (forall N3 . member(N3,S) -> (intact(N3) & accepted_prepared(N3,b,v)))))
        proof {
            tactic l2s with
            invariant ~(l2s_waiting & l2s_frozen) & ~(l2s_frozen & l2s_saved) & ~(l2s_waiting & l2s_saved)
            invariant l2s_d(N:node) & l2s_d(B:ballot) & l2s_d(V:value)
            invariant l2s_frozen -> l2s_a(N:node) & l2s_a(B:ballot) & l2s_a(V:value)

            # negation of the goal:
            invariant globally ~globally ((forall N . intact(N) -> accepted_prepared(N,b,v)) | (exists N2,S . intact(N2) & ~accepted_prepared(N2,b,v) & blocks_slices(S,N2) & (forall N3 . member(N3,S) -> (intact(N3) & accepted_prepared(N3,b,v)))))
            invariant ~globally ((forall N . intact(N) -> accepted_prepared(N,b,v)) | (exists N2,S . intact(N2) & ~accepted_prepared(N2,b,v) & blocks_slices(S,N2) & (forall N3 . member(N3,S) -> (intact(N3) & accepted_prepared(N3,b,v)))))

            invariant exists N1,N2,B,V . intact(N1) & intact(N2) & ~globally (confirmed_prepared(N1,B,V) -> eventually confirmed_prepared(N2,B,V))
            # resulting witnesses:
            invariant intact(n1) & intact(n2) & ~globally (confirmed_prepared(n1,b,v) -> eventually confirmed_prepared(n2,b,v))

            # at the save point, n1 has confirmed prepared and n2 has not:
            invariant ($l2s_w . ~(confirmed_prepared(n1,b,v) -> eventually confirmed_prepared(n2,b,v))) | (confirmed_prepared(n1,b,v) & globally ~confirmed_prepared(n2,b,v))
            invariant (l2s_frozen | l2s_saved) -> confirmed_prepared(n1,b,v) & globally ~confirmed_prepared(n2,b,v)
            invariant l2s_saved -> $was$ confirmed_prepared(n1,b,v) & ~confirmed_prepared(n2,b,v)

            invariant intact(n1) & confirmed_prepared(n1,b,v) -> exists Q . is_quorum(Q) & member(n1,Q) & (forall N . intact(N) & member(N,Q) -> received_accept_prepare(n1,N,b,v))
            invariant well_behaved(N) & received_accept_prepare(N,N2,B,V) & well_behaved(N2) -> accepted_prepared(N2,B,V)
            invariant (l2s_frozen | l2s_saved) -> exists Q . is_quorum(Q) & member(n1,Q) & (forall N . intact(N) & member(N,Q) -> accepted_prepared(N,b,v))

            # NOTE: the two last invariants pass because [cascade] is a property. It would not work if it was an invariant because we would have to assume it in the post-state too, and we can't use tactics
            invariant (l2s_frozen | l2s_saved) -> ((forall N . intact(N) -> accepted_prepared(N,b,v)) | (exists N2,S . intact(N2) & ~accepted_prepared(N2,b,v) & blocks_slices(S,N2) & (forall N3 . member(N3,S) -> (intact(N3) & accepted_prepared(N3,b,v)))))
            invariant l2s_saved -> ($l2s_w. ~((forall N . intact(N) -> accepted_prepared(N,b,v)) | (exists N2,S . intact(N2) & ~accepted_prepared(N2,b,v) & blocks_slices(S,N2) & (forall N3 . member(N3,S) -> (intact(N3) & accepted_prepared(N3,b,v))))))
        }

        #temporal property (
            ## fair message delivery:
            #(forall N1,N2,B,V . intact(N1) & intact(N2) -> globally (accepted_prepared(N1,B,V) -> eventually received_accept_prepare(N2,N1,B,V)))
            ## witnesses n1, n2, b, and v (for the negation of the conclusion below):
            #& ( (forall N1,N2,B,V.
                    #intact(N1) & intact(N2) -> globally (confirmed_prepared(N1,B,V) -> eventually confirmed_prepared(N2,B,V)))
                #| ( intact(n1) & intact(n2) & ~globally (confirmed_prepared(n1,b,v) -> eventually confirmed_prepared(n2,b,v)))
              #)
            ## witnesses n3 and s (we do a case split on this prophecy):
            #& ((exists N3,S .
                    #eventually globally (intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v)))))
                #->  eventually globally (intact(n3) & ~accepted_prepared(n3,b,v) & blocks_slices(s,n3) & (forall N . member(N,s) -> (intact(N) & accepted_prepared(N,b,v)))))
            ## conclusion:
            #) -> forall N1,N2,B,V . intact(N1) & intact(N2) -> globally (confirmed_prepared(N1,B,V) -> eventually confirmed_prepared(N2,B,V))
        #proof {
            #tactic l2s with
            #invariant ~(l2s_waiting & l2s_frozen) & ~(l2s_frozen & l2s_saved) & ~(l2s_waiting & l2s_saved)
            #invariant l2s_d(N:node) & l2s_d(B:ballot) & l2s_d(V:value)
            #invariant l2s_frozen -> l2s_a(N:node) & l2s_a(B:ballot) & l2s_a(V:value)

            ## fairness of message delivery:
            #invariant intact(N1) & intact(N2) -> globally (accepted_prepared(N1,B,V) -> eventually received_accept_prepare(N2,N1,B,V))
            ##invariant intact(N1) & intact(N2) & accepted_prepared(N1,B,V) -> eventually received_accept_prepare(N2,N1,B,V)
            #invariant intact(N1) & intact(N2) -> ($l2s_w N1,N2,B,V. received_accept_prepare(N2,N1,B,V))(N1,N2,B,V) | received_accept_prepare(N2,N1,B,V) | globally ~received_accept_prepare(N2,N1,B,V)
            #invariant intact(N1) & intact(N2) & accepted_prepared(N1,B,V) -> ($l2s_w N1,N2,B,V. received_accept_prepare(N2,N1,B,V))(N1,N2,B,V) | received_accept_prepare(N2,N1,B,V)

            ## the prophecy case split: (a) | (b)
            #invariant  (forall N3,S . globally (~globally (intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v)))))) | (exists N3,S . eventually globally (intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v)))))

            ## case (b)
            ## here we easily prove that we never stop waiting, otherwise, by [additional_safety.inv1], n3 accepts (b,v) as prepared
            #invariant (exists N3,S . eventually globally (intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v)))))
                #-> eventually globally (intact(n3) & ~accepted_prepared(n3,b,v) & blocks_slices(s,n3) & (forall N . member(N,s) -> (intact(N) & accepted_prepared(N,b,v))))
            #invariant (exists N3,S . eventually globally (intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v)))))
                #-> ($l2s_w. globally (intact(n3) & ~accepted_prepared(n3,b,v) & blocks_slices(s,n3) & (forall N . member(N,s) -> (intact(N) & accepted_prepared(N,b,v))))) | globally (intact(n3) & ~accepted_prepared(n3,b,v) & blocks_slices(s,n3) & (forall N . member(N,s) -> (intact(N) & accepted_prepared(N,b,v))))
            #invariant (exists N3,S . eventually globally (intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v))))) & (l2s_frozen | l2s_saved)
                #-> globally (intact(n3) & ~accepted_prepared(n3,b,v) & blocks_slices(s,n3) & (forall N . member(N,s) -> (intact(N) & accepted_prepared(N,b,v))))
            #invariant (exists N3,S . eventually globally (intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v))))) & l2s_saved
                #-> (forall N . member(N,s) -> ($l2s_w N1,N2,B,V. received_accept_prepare(N2,N1,B,V))(N,n3,b,v) | received_accept_prepare(n3,N,b,v))

            ## case (a)

            ## negation of the goal:
            #invariant exists N1,N2,B,V . intact(N1) & intact(N2) & ~globally (confirmed_prepared(N1,B,V) -> eventually confirmed_prepared(N2,B,V))
            ## resulting witnesses:
            #invariant intact(n1) & intact(n2) & ~globally (confirmed_prepared(n1,b,v) -> eventually confirmed_prepared(n2,b,v))

            ## at the save point, n1 has confirmed prepared and n2 has not:
            #invariant ($l2s_w . ~(confirmed_prepared(n1,b,v) -> eventually confirmed_prepared(n2,b,v))) | (confirmed_prepared(n1,b,v) & globally ~confirmed_prepared(n2,b,v))
            #invariant (l2s_frozen | l2s_saved) -> confirmed_prepared(n1,b,v) & globally ~confirmed_prepared(n2,b,v)
            #invariant l2s_saved -> $was$ confirmed_prepared(n1,b,v) & ~confirmed_prepared(n2,b,v)

            ## now we show that, because we have `globally ~confirmed_prepared(n2,b,v)`, there is a message from intact to intact that is never received (this involves the cascade theorem); thus, we never stop waiting. QED.

            #invariant intact(n1) & confirmed_prepared(n1,b,v) -> exists Q . is_quorum(Q) & member(n1,Q) & (forall N . intact(N) & member(N,Q) -> received_accept_prepare(n1,N,b,v))
            #invariant well_behaved(N) & received_accept_prepare(N,N2,B,V) & well_behaved(N2) -> accepted_prepared(N2,B,V)
            #invariant (l2s_frozen | l2s_saved) -> exists Q . is_quorum(Q) & member(n1,Q) & (forall N . intact(N) & member(N,Q) -> accepted_prepared(N,b,v))
            ## now this shoudl be trivial with [additional_safety.cascade], but it is a problem because we can't use tactics:
            #invariant (l2s_frozen | l2s_saved) -> ((forall N . intact(N) -> accepted_prepared(N,b,v)) | (exists N2,S . intact(N2) & ~accepted_prepared(N2,b,v) & blocks_slices(S,N2) & (forall N3 . member(N3,S) -> (intact(N3) & accepted_prepared(N3,b,v)))))
            ##invariant (l2s_frozen | l2s_saved) -> (forall N . intact(N) -> accepted_prepared(N,b,v)) # case (a)

            #invariant  l2s_saved -> ($l2s_w N3,S. ~(intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v)))))(N3,S) | (forall N . intact(N) -> accepted_prepared(N,b,v)) | globally (intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v))))
            ##invariant (globally (~globally (intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v)))))) & l2s_saved & ~($l2s_w N3,S. ~(intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v)))))(N3,S) -> (forall N . intact(N) -> accepted_prepared(N,b,v))

            ##| ~(intact(N3) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v))))
            ##invariant (globally (~globally (intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v)))))) & l2s_saved & (intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v)))) -> ($l2s_w N3,S. ~(intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v)))))

            ## Now we have two cases: either (a) all intact nodes accepted (b,v) as prepared, or (b) one intact node that did not is blocked by a set of intact nodes that accepted (b,v) as prepared
            ## In case (a), n2 will confirm (b,v) prepared when receiving those messages, which contradicts `globally ~confirmed_prepared(n2,b,v)`
            ## In case (b), let n3 be the blocked node and s the blocking s; when receiving all messages from the set s, n3 will newly accept (b,v) as prepared, and thus saved state and current state will differ

            ## case (a)
            #invariant intact(N1) & N2=n2 & B=b & V=v -> (($l2s_w N1,N2,B,V . received_accept_prepare(N2,N1,B,V))(N1,N2,B,V) | received_accept_prepare(n2,N1,b,v) | globally ~received_accept_prepare(N2,N1,B,V))
            #invariant intact(N1) & N2=n2 & B=b & V=v & accepted_prepared(N1,b,v) -> (($l2s_w N1,N2,B,V . received_accept_prepare(N2,N1,B,V))(N1,N2,B,V) | received_accept_prepare(n2,N1,b,v))
            #invariant (forall N. intact(N) -> received_accept_prepare(n2,N,b,v)) -> confirmed_prepared(n2,b,v)
            ## end case (a)

            ## case (a)
            #invariant (globally (~globally (intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v)))))) -> ~globally (intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v))))
            ##invariant ($l2s_w N3,S. ~(intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v)))))(N3,S) | ~(intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v)))) | globally (intact(N3) & ~accepted_prepared(N3,b,v) & blocks_slices(S,N3) & (forall N . member(N,S) -> (intact(N) & accepted_prepared(N,b,v))))




        #}
    } with actions, node_properties, quorum_properties.intact_is_quorum
}
