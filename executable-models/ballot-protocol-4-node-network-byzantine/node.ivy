#lang ivy1.7

object node = {
    # For some reason treating the following relation definitions as assignments in
    # an 'after init' block means that Ivy considers the possibility of the
    # relations having different values, when exploring possible prestates for
    # actions, though it seems like it should not.

    # Generated by relation.py
    relation member(X:id_t, S:set_t)
    definition member(X:id_t, S:set_t) =
        (X=0&S=1)|(X=0&S=3)|(X=0&S=5)|(X=0&S=7)|(X=0&S=9)|(X=0&S=11)|(X=0&S=13)|(X=0&S=15)|(X=1&S=2)|(X=1&S=3)|(X=1&S=6)|(X=1&S=7)|(X=1&S=10)|(X=1&S=11)|(X=1&S=14)|(X=1&S=15)|(X=2&S=4)|(X=2&S=5)|(X=2&S=6)|(X=2&S=7)|(X=2&S=12)|(X=2&S=13)|(X=2&S=14)|(X=2&S=15)|(X=3&S=8)|(X=3&S=9)|(X=3&S=10)|(X=3&S=11)|(X=3&S=12)|(X=3&S=13)|(X=3&S=14)|(X=3&S=15)

    relation is_quorum(S:set_t)
    definition is_quorum(S:set_t) =
        (S=7)|(S=11)|(S=13)|(S=14)|(S=15)

    relation is_v_blocking(X:id_t, S:set_t)
    definition is_v_blocking(X:id_t, S:set_t) =
        ~((X=0&S=0)|(X=0&S=2)|(X=0&S=4)|(X=0&S=8)|(X=1&S=0)|(X=1&S=1)|(X=1&S=4)|(X=1&S=8)|(X=2&S=0)|(X=2&S=1)|(X=2&S=2)|(X=2&S=8)|(X=3&S=0)|(X=3&S=1)|(X=3&S=2)|(X=3&S=4))

    # In general, well behaved nodes may not be intact or intertwined.
    # However, in this specific network, well_behaved = intact = intertwined.
    # Since this is the first model that introduces Byzantine behaviors,
    # we will keep things very simple and only define the well_behaved relation.
    relation well_behaved(N:id_t)
    definition well_behaved(N:id_t) = N~=3

    # These relations are state variables, and will
    # be updated during actions below.
    relation voted(TYPE:statement_t, SELF:id_t, BAL:ballot_t)
    relation accepted(TYPE:statement_t, SELF:id_t, BAL:ballot_t)
    relation confirmed(TYPE:statement_t, SELF:id_t, BAL:ballot_t)
    relation heard_vote(TYPE:statement_t, SELF:id_t, SRC:id_t, BAL:ballot_t)
    relation heard_accept(TYPE:statement_t, SELF:id_t, SRC:id_t, BAL:ballot_t)
    relation compatible_with_nomination_output(SELF:id_t, BAL:ballot_t)

    after init {
        voted(TYPE, SELF, BAL) := false;
        accepted(TYPE, SELF, BAL) := false;
        confirmed(TYPE, SELF, BAL) := false;
        heard_vote(TYPE, SELF, SRC, BAL) := false;
        heard_accept(TYPE, SELF, SRC, BAL) := false;
        compatible_with_nomination_output(SELF, BAL) := false;
    }

    # The remaining relations are definitions, used as
    # abbreviations inside logical formulas elsewhere.
    relation heard_set_vote_or_accept(TYPE:statement_t, SELF:id_t, SET:set_t, BAL:ballot_t)
    definition heard_set_vote_or_accept(TYPE, SELF, S, BAL) =
        forall V. member(V, S) ->
            (
                heard_vote(TYPE, SELF, V, BAL) |
                heard_accept(TYPE, SELF, V, BAL)
            )

    relation heard_set_accept(TYPE:statement_t, SELF:id_t, SET:set_t, BAL:ballot_t)
    definition heard_set_accept(TYPE, SELF, S, BAL) =
        forall V. member(V, S) -> heard_accept(TYPE, SELF, V, BAL)

    relation accept_condition_1(TYPE:statement_t, SELF:id_t, BAL:ballot_t)
    definition accept_condition_1(TYPE, SELF, BAL) =
        exists Q.
            (
                is_quorum(Q) &
                member(SELF, Q) &
                heard_set_vote_or_accept(TYPE, SELF, Q, BAL)
            )

    relation accept_condition_2(TYPE:statement_t, SELF:id_t, BAL:ballot_t)
    definition accept_condition_2(TYPE, SELF, BAL) =
        exists S.
            (
                ~member(SELF, S) &
                is_v_blocking(SELF, S) &
                heard_set_accept(TYPE, SELF, S, BAL)
            )

    relation voted_to_commit_lesser_incompatible_ballot_t(SELF:id_t, BAL:ballot_t)
    definition voted_to_commit_lesser_incompatible_ballot_t(SELF, BAL) =
        exists BAL2. ~compatible(BAL, BAL2) & BAL2 < BAL & voted(commit, SELF, BAL2)


    relation accepted_to_commit_lesser_incompatible_ballot_t(SELF:id_t, BAL:ballot_t)
    definition accepted_to_commit_lesser_incompatible_ballot_t(SELF, BAL) =
        exists BAL2. ~compatible(BAL, BAL2) & BAL2 < BAL & accepted(commit, SELF, BAL2)

    # Checks whether SELF has voted abort(BAL).
    # By definition, a ballot b is prepared if and only if { abort(b') | b' ⋦ b }.
    # Therefore, if SELF has voted to prepare greater, incompatible BAL2,
    # then that implies that SELF has voted abort(BAL).
    relation voted_abort(SELF:id_t, BAL:ballot_t)
    definition voted_abort(SELF, BAL) =
        exists BAL2. BAL2 > BAL & ~compatible(BAL, BAL2) & voted(prepare, SELF, BAL2)


    # See the comment above for voted_abort.
    relation accepted_abort(SELF:id_t, BAL:ballot_t)
    definition accepted_abort(SELF, BAL) =
        exists BAL2. BAL2 > BAL & ~compatible(BAL, BAL2) & accepted(prepare, SELF, BAL2)

    # Notes for when TYPE = prepare:
    # prepare(bal) is actually a collection of statements.
    # By definition, accepting to prepare bal is equivalent to
    # accepting each statement in { abort(bal') | bal' ⋦ bal }.
    #
    # When TYPE = commit, it checks whether SELF is ready to accept, but has not accepted commit(BAL).
    # 1. `~accepted_abort(SELF, BAL)`
    #    -> We can accept only if we have not aborted it.
    # 2. `confirmed(prepare, SELF, BAL)`
    #    -> This condition is necessary since P.20 of the white paper states:
    #
    #       > To commit a ballot b and externalize its value b.x,
    #       > SCP nodes first accept and confirm b is prepared, then accept and confirm commit b.
    relation ready_to_accept_but_have_not_accepted(TYPE:statement_t, SELF:id_t, BAL:ballot_t)
    definition ready_to_accept_but_have_not_accepted(TYPE, SELF, BAL) =
        ~accepted(TYPE, SELF, BAL) &
        (
            (TYPE = prepare & ~accepted_to_commit_lesser_incompatible_ballot_t(SELF, BAL)) | # Prepare
            (TYPE = commit & ~accepted_abort(SELF, BAL) & confirmed(prepare, SELF, BAL))     # Commit
        ) & (
            accept_condition_1(TYPE, SELF, BAL) |
            accept_condition_2(TYPE, SELF, BAL)
        )

    relation ready_to_confirm_but_have_not_confirmed(TYPE:statement_t, SELF:id_t, BAL:ballot_t)
    definition ready_to_confirm_but_have_not_confirmed(TYPE, SELF, BAL) =
        ~confirmed(TYPE, SELF, BAL) &
        exists Q.
            (
                is_quorum(Q) &
                member(SELF, Q) &
                heard_set_accept(TYPE, SELF, Q, BAL)
            )

    # `self_id` confirms `NOMINATE(bal.x)`.
    # We can't just pass the value here since this model doesn't know
    # about `bal.x` and `bal.n`.
    action confirm_nominate(self_id:id_t, bal:ballot_t) =
    {
        compatible_with_nomination_output(self_id, BAL) := compatible(BAL, bal);
    }

    # self_id votes to prepare/commit bal.
    action vote(statement_type:statement_t, self_id:id_t, bal:ballot_t) =
    {
        require ~voted(statement_type, self_id, bal);

        if (statement_type = commit) {
            # We need to make sure that we have confirmed prepare(bal).
            #
            # > More precisely, then, commit b is valid to vote for only if b is confirmed prepared,
            # > which nodes ensure through federated voting on the corresponding abort statements.
            #
            # from P.22 of the white paper.
            require confirmed(prepare, self_id, bal);

            require ~voted_abort(self_id, bal);
            require ~accepted_abort(self_id, bal);
        } else {
            # Since we're trying to vote to prepare bal,
            # we must make sure that we haven't voted or accepted to commit
            # a lesser, incompatible ballot.
            #
            # P.22 of the white paper states:
            #
            # > For a given ballot, commit and abort are contradictory,
            # > so a well-behaved node may vote for at most one of them.
            require ~voted_to_commit_lesser_incompatible_ballot_t(self_id, bal);
            require ~accepted_to_commit_lesser_incompatible_ballot_t(self_id, bal);

            require compatible_with_nomination_output(self_id, bal);
        };


        voted(statement_type, self_id, bal) := true;
        heard_vote(statement_type, self_id, self_id, bal) := true;

        if ready_to_accept_but_have_not_accepted(statement_type, self_id, bal) {
            accepted(statement_type, self_id, bal) := true;
            heard_accept(statement_type, self_id, self_id, bal) := true;
        };

        if ready_to_confirm_but_have_not_confirmed(statement_type, self_id, bal) {
            confirmed(statement_type, self_id, bal) := true;
            if (statement_type = prepare) {
                # Confirming `prepare(bal)` might let us accept `commit(bal)`
                # based on messages that we've already received.
                if ready_to_accept_but_have_not_accepted(commit, self_id, bal) {
                    accepted(commit, self_id, bal) := true;
                    heard_accept(commit, self_id, self_id, bal) := true;
                };
                if ready_to_confirm_but_have_not_confirmed(commit, self_id, bal) {
                    confirmed(commit, self_id, bal) := true;
                };
            };
        };
    }

    action recv_vote(statement_type:statement_t, self_id:id_t, src:id_t, bal:ballot_t) =
    {
        heard_vote(statement_type, self_id, src, bal) := true;
        if ready_to_accept_but_have_not_accepted(statement_type, self_id, bal) {
            accepted(statement_type, self_id, bal) := true;
            heard_accept(statement_type, self_id, self_id, bal) := true;
        };
        if ready_to_confirm_but_have_not_confirmed(statement_type, self_id, bal) {
            confirmed(statement_type, self_id, bal) := true;
            if (statement_type = prepare) {
                # Confirming `prepare(bal)` might let us accept `commit(bal)`
                # based on messages that we've already received.
                if ready_to_accept_but_have_not_accepted(commit, self_id, bal) {
                    accepted(commit, self_id, bal) := true;
                    heard_accept(commit, self_id, self_id, bal) := true;
                };
                if ready_to_confirm_but_have_not_confirmed(commit, self_id, bal) {
                    confirmed(commit, self_id, bal) := true;
                };
            };
        };
    }

    action recv_accept(statement_type:statement_t, self_id:id_t, src:id_t, bal:ballot_t) =
    {
        heard_accept(statement_type, self_id, src, bal) := true;
        if ready_to_accept_but_have_not_accepted(statement_type, self_id, bal) {
            accepted(statement_type, self_id, bal) := true;
            heard_accept(statement_type, self_id, self_id, bal) := true;
        };
        if ready_to_confirm_but_have_not_confirmed(statement_type, self_id, bal) {
            confirmed(statement_type, self_id, bal) := true;
                if (statement_type = prepare) {
                # Confirming `prepare(bal)` might let us accept `commit(bal)`
                # based on messages that we've already received.
                if ready_to_accept_but_have_not_accepted(commit, self_id, bal) {
                    accepted(commit, self_id, bal) := true;
                    heard_accept(commit, self_id, self_id, bal) := true;
                };
                if ready_to_confirm_but_have_not_confirmed(commit, self_id, bal) {
                    confirmed(commit, self_id, bal) := true;
                };
            };
        };
    }

    action byzantine_step = {
        voted(TYPE, NODE, BAL) := *;
        assume forall NODE. (well_behaved(NODE) -> (forall BAL. voted(TYPE, NODE, BAL) = old voted(TYPE, NODE, BAL)));

        accepted(TYPE, NODE, BAL) := *;
        assume forall NODE. (well_behaved(NODE) -> (forall BAL. accepted(TYPE, NODE, BAL) = old accepted(TYPE, NODE, BAL)));

        confirmed(TYPE, NODE, BAL) := *;
        assume forall NODE. (well_behaved(NODE) -> (forall BAL. confirmed(TYPE, NODE, BAL) = old confirmed(TYPE, NODE, BAL)));

        heard_vote(TYPE, SELF, SRC, BAL) := *;
        assume forall SELF. (well_behaved(SELF) -> (forall SRC, BAL. heard_vote(TYPE, SELF, SRC, BAL) = old heard_vote(TYPE, SELF, SRC, BAL)));

        heard_accept(TYPE, SELF, SRC, BAL) := *;
        assume forall SELF. (well_behaved(SELF) -> (forall SRC, BAL. heard_accept(TYPE, SELF, SRC, BAL) = old heard_accept(TYPE, SELF, SRC, BAL)));

        compatible_with_nomination_output(SELF, BAL) := *;
        assume forall SELF. (well_behaved(SELF) -> (forall BAL. compatible_with_nomination_output(SELF, BAL) = old compatible_with_nomination_output(SELF, BAL)));
    }
}
